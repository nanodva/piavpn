#!/bin/bash

## piavpn v0.1 Copyright (C) 2019 TaigaSan Corp <taigasan@sdf.org>
#
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License Version 2 as published by
## the Free Software Foundation.
#
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License at (http://www.gnu.org/licenses/) for
## more details.

### DECLARATIONS ###
# all folders name depends of Pname
PNAME=$(basename $0 .sh)
# external file for values, to share with other programs
. globals.conf

# Flags:
# highly verbose mode
debug=true
# do not ask for protocol or server
auto=true
auto=false



### FUNCTIONS ###


ftestportforwarding()
{
	echo "test port forwarding"
	cd $VPNPATH
	while read -r NAME URL; do
		CONFIG="$NAME.ovpn"
		echo $CONFIG
		openvpn --config $CONFIG &
		pid=$!
		sleep 5
		kill $pid
	done < servers.txt
	# curl -v -m 4 "http://209.222.18.222:2000/?client_id=$(cat $VPNPATH/client_id)"
	exit
}





f_parse_ovpn_output()
{
	# active filter for openvpn stdout
	# print both to log and terminal

	# split line in date, info
	while read -r d m n h y info; do
		# print to log
		# printf "openvpn: %s\n" "$info" >> $LOG
		log "openvpn: %s" "$info"
		
		if [[ "$info" =~ "Attempting to establish" ]]; then
			info "connecting..."
			status="connecting"
		elif [[ "$info" =~ ^(TCP|UDP) ]]; then
			info=$(echo "$info" | tail -c+4)
			if [[ "$info" =~ "connection established" ]]; then
				info "connected"
				status="connected"
			fi
		elif [[ "$info" =~ 'failed' ]]; then

			error "failed: %s" "$info"
		elif [[ "$info" =~ 'Initialization Sequence Completed' ]]; then
			info "Tunnel initialization completed\n"
			info -t "Tunnel initialized"
			status="active"
		fi
	done
}


f_make_ovpn_config_file()
{
	# parse config file for openvpn. print to stdout
	make_template()
	{
		# ---template default ---
		cat <<-EOF
		# this file is auto-generated by ${PNAME}
		# any changes will be overwritten

		client
		dev tun
		proto ${proto}
		remote ${url} ${port}
		resolv-retry infinite
		nobind
		persist-key
		persist-tun
		cipher ${cipher}
		auth ${hash}
		tls-client
		remote-cert-tls server

		auth-user-pass ${CREDENTIALS}
		auth-nocache
		compress
		verb 2
		reneg-sec 0

		<crl-verify>
		EOF
		cat ${LIBPATH}/${crl}
		cat <<-EOF
		</crl-verify>

		<ca>
		EOF
		cat ${LIBPATH}/${ca}
		cat <<-EOF
		</ca>

		disable-occ
		EOF
	# ---end template---
	}

	get_value()
	{
		# return field value for specific server from servers.txt
		field=$1
		cat $SRV_CONF |\
			grep -A7 -E "$servername" |\
			grep $field |\
			cut -d "=" -f2  
	}

	debug "parsing ovpn config file"

	# parsing parameters
	servername="$1"
	protocol="$2"
		
	# get server data
	url=$(get_value url)
	ip=$(get_value ip)

	# port on server
	case $protocol in
		"tcp")
			proto="tcp"
			port=$(get_value tcp_port)
			security="default" ;;
		"udp")
			proto="udp"
		 	port=$(get_value udp_port)
			security="default" ;;
		"strong tcp")
			proto="tcp"
			port=$(get_value tcps_port)
			security="strong" ;;
		"strong udp")
			proto="udp"
			port=$(get_value udps_port)
			security="strong" ;;
	esac

	# certificates and level of encryption
	case $security in
		"default")
			crl="crl.rsa.2048.pem"
			ca="ca.rsa.2048.crt"
			cipher="aes-128-cbc"
			hash="sha1" ;;
		"strong")
			crl="crl.rsa.4096.pem"
			ca="ca.rsa.4096.crt"
			cipher="aes-256-cbc"
			hash="sha256" ;;
	esac


	info "server: %s, %s [%s]" "$servername" "$url" "$ip"
	info "protocol:%s  port:%d" "$protocol" "$port"
	debug "crl: %s, ca: %s" "$crl" "$ca"
	debug "cipher:%s  sha:%s" "$cipher" "$hash"
	debug "\nParsed config file:"
	debug "$(make_template)"

	# make_template > $VPN_CONF
	make_template
}

f_choose_protocol()
{
	# display a select menu, return choosen protocol
	info -t -n "Protocol selection:"

	PS3="Select a protocol: "
	select protocol in "tcp" "strong tcp" "udp" "strong udp"; do
		if [[ ! $protocol ]]; then
			error "invalid entry\n"
			PS3="Enter the selected number [1-4] : "
			continue
		else
			debug "protocol: %s" "$protocol"
			break
		fi
	done

	# return protocol name
	echo $protocol
}

f_list_servers()
{
	# print servers list to stdout
	# in server.conf, servers names are closed in brackets []
	cat $SRV_CONF | grep -E "^\[" | grep -oE "[a-Z ]+"
}

f_choose_server_from_list()
{
	# display a menu, return choosen servername
	info -t -n "Server selection:"

	# split file on new line, not space characters
	IFS_BAK=$IFS
	IFS=$'\n'
	PS3="Server number: "
	select servername in $(f_list_servers); do
		if [[ ! $servername ]]; then
			error "invalid entry"
			n=$(f_list_servers | wc -l)
			PS3="Enter the selected number [1-$n] :" 
			continue
		else
			debug "server: %s" "$servername"
			break
		fi
	done
	IFS=$IFS_BAK

	# return server name
	echo $servername
}

f_init_credentials()
{
	# credentials are (quite) securely stored. for auto login
	dir=$(dirname $CREDENTIALS)
	if [[ ! -d $dir ]]; then
		install -d -m 700 $dir
		# mkdir -p $dir && chmod 700 $dir
	fi
	
	# double check dir access on each start
	mode=$(stat -c %a $dir)
	if [[ $mode != "700" ]]; then
		error "${dir} mode must be 700. mode changed"
		chmod 700 $dir
	fi

	if [[ ! -f $CREDENTIALS ]]; then
		printf "your PIA credentials will be stored for further login\n"
		printf "$PROMPT username: "
		read USERNAME

		printf "$PROMPT password: "
		read -s PASSWORD && printf '\n'

		printf "$USERNAME\n$PASSWORD\n" > $CREDENTIALS

		unset USERNAME PASSWORD
		chmod 400 $CREDENTIALS
	fi

	# force restricted mode at each start
	mode=$(stat -c %a $CREDENTIALS)
	if [[ $mode != "400" ]]; then
		error "$CREDENTIALS mode must be 400. mode changed"
		chmod 400 $CREDENTIALS
	fi

	return 0
}

f_update_servers_data()
{
	##Automaticaly updates server list
	## all servers data will come from pia conf.ovpn files
	## they are provided by PrivateInternetAccess in Zip files
	## certificates are included in those zip archives
	## see https://www.privateinternetaccess.com/openvpn
	fcurlzip()
	# download and extract zip file
	{
		zip=$1
		url=${PIA_URL}/openvpn/${zip}
		debug "downloading %s" $url

		# ask server for file existence
		# TODO: test modification date (curl -z --time-cond)
		header=$(curl --silent --head $url)
		response=$(head -n1 <<< $header)
		read -r xx status info <<< $response
		debug "response: %s %s" $status "$info"

		# extract archive and clean
		if [[ $status == "200" ]]; then
			options="--silent"
			$debug && options=""
			curl $options -o $zip $url
			unzip -qo $zip
			rm $zip
			return 0
		else
			error "'%s' download failed: %s %s\n" $url $status "$info"
			rm $zip
			return 1
		fi
	}

	info "updating servers data"

	
	# files will be extracted in tmp
	# concatenate at the end
	tmpdir=$(mktemp -d)
	cd $tmpdir

	# make a file for each server in this folder
	mkdir servers 
	
	taglist=("ip" "tcp" "strong" "strong-tcp")
	# info to read dependis on zip file
	# each expression will be evaluated ( cmd: eval )
	# get IP and UDP port from ip.zip
	ip_info='ip=${X}\\nudp_port=${Y}\\n'
	# get URL and TCP port from tcp.zip
	tcp_info='url=${X}\\ntcp_port=${Y}\\n'
	# get secure UDP port from strong.zip
	strong_info='udps_port=${Y}\\n'
	# get secure TCP port from tcp-strong.zip
	# ('-' is not allowed in name)
	strong_tcp_info='tcps_port=${Y}\\n'

	for tag in ${taglist[@]}; do
		# loop through zip archives
		zip="openvpn-${tag}.zip"
		fcurlzip $zip || return 1

		# useful info to store in server config file
		infolist=$(echo ${tag}_info | tr '-' '_')
		taginfo=$(eval echo \$${infolist})

		while read file; do
			# make a temp file for each server
			name=$(basename "$file" .ovpn)
			datafile="./servers/${name}"
			# all files will be concatenated in one
			if [[ ! -f "$datafile" ]]; then
					echo "[$name]" > "$datafile"
					echo "name=\"${name}\"" >> "$datafile"
			fi

			# stroe info
			read -r none X Y <<< $(cat "$file" | grep -m1 ^remote )
			# evaluation of the pre-evaluation
			eval printf "$taginfo" >> "$datafile"
			# clean
			rm "$file"
		done <<< $(ls *.ovpn)
	done		

	# concatenate all datas in one file
	tmp_conf="$server/server.conf"
	cat > $tmp_conf <<-EOF
		# this file is auto-generated with ${PNAME}
		# any changes will be overwritten
	EOF
	while read file; do
		cat "$file" >> $tmp_conf
		printf "\n" >> $tmp_conf
	done <<< $(ls servers/*)

	# certificates remains behind
	debug "saving certificates:"
	for certif in $(ls *.crt *.pem | sort ); do
		debug ".. %s" $certif
		mv $certif $LIBPATH
	done

	# move config file in place
	mv $tmp_conf $SRV_CONF
	

	# clean
	rm -r $tmpdir
	return 0
}

f_init_servers_data()
{
	# check server list
	if [[ ! -f $SRV_CONF ]]; then
		if (f_update_servers_data); then
			info "update succeed"
		else
			error "update failed"
			return 1
		fi
	fi
}

f_init_log()
{
	## make a clean new log at each start
	echo "----------------" > $LOG
	echo "init log" $(date) >> $LOG
}

f_init_folders() 
{
	# status; checked
	## RUNPATH: folder for process data(log, etc)
	## LIBPATH: data files are stored there

	for folder in $RUNPATH $LIBPATH; do
		if [[ ! -d $folder ]]; then
			debug "make dir '%s'\n" $folder
			mkdir -p $folder
			if [[ $? != 0 ]]; then
				error "unable to make dir $folder"
				return 1
			fi
		fi
	done
}

f_init()
{
	info "initializing..."

	f_init_folders || return 1
	f_init_log || return 1
	f_init_servers_data || return 1

	# ask for credentials if not stored yet
	f_init_credentials || return 1

	info "initialization succeed"
	return 0
}

log()
{
	# print msg to log file $LOG
	msg=$(printf "$@")
	printf "%s\n" "$msg" >> $LOG
}

info()
{
	## display info line to stderr
	## usage: info [options] <message>
	#
	## message: is parsed with printf
	tag="info"
	fmt="${tag}: %s\n"
	## options:
	# case $1 in
	for arg in $@; do
	case $arg in
	# -n 	: add a line break before message
	'-n')	shift
			printf "\n" >&2
			;;
	# title format, bold text
	'-t')	shift
			fmt="\033[1m%s\033[0m\n"
			;;
	esac
	done

	msg=$(printf "$@")
	
	printf "$fmt" "$msg" >&2
}

error()
{
	msg=$(printf "$@")
	# printf "error: %s\n" "$msg"
	printf "\033[91m%s\033[0m\n" "$msg" >&2
}

debug()
{
	# be more verbose when global debug=true
	if $debug; then
		msg=$(printf "$@")
		# printf "debug: %s\n" "$msg"
		printf "\033[2m%s\033[0m\n" "$msg" >&2
	fi
}

## DMZ
### MAIN BEGIN ###
debug "this is debug %s" mode

# Only root can change ip routes and network interfaces
if [[ $(id -u) != 0 ]]; then
	echo "$ERROR Script must be run as root."
	exit 1
fi

if ! f_init; then
	echo "unable to initialize"
	exit 1
fi

if $auto ; then
	# connect to closest server
	servername=$(./diagnose.sh | head -n1)
	protocol="tcp"
else
	# ask for server to use
	servername=$(f_choose_server_from_list)
	protocol=$(f_choose_protocol)
fi

# parse config file
vpn_conf=$(mktemp)
f_make_ovpn_config_file "$servername" "$protocol" > $vpn_conf

# connect
info -t "setting tunnel up"
openvpn --config $vpn_conf | f_parse_ovpn_output

cat $LOG

exit

